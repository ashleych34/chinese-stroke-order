<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stroke Diagram</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #target { width: 420px; height: 420px; border: 1px solid #ddd; display: grid; place-items: center; }
    .hint { margin-top: 10px; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <div id="target"></div>
  <div class="hint">Try: 我, 永, 愛, 龍</div>

  <script>
    // --- Stroke diagram renderer (pure frontend) ---

    const HanziStrokeData = (() => {
      // Cache: char -> data
      const cache = new Map();

      function toCodePoints(str) {
        // Handles surrogate pairs correctly
        const cps = [];
        for (const ch of str) cps.push(ch.codePointAt(0));
        return cps;
      }

      function isSingleGrapheme(str) {
        // Accept a single Unicode "character" (including surrogate-pair CJK extensions)
        const cps = toCodePoints(str);
        return cps.length === 1;
      }

      async function loadCharData(char, opts = {}) {
        if (!isSingleGrapheme(char)) {
          throw new Error(`Expected a single character, got "${char}"`);
        }
        if (cache.has(char)) return cache.get(char);

        const cdnBase = opts.cdnBase || "https://unpkg.com/hanzi-writer-data@2.0.1";
        // Files are named like: /我.json, /亞.json, ...
        const url = `${cdnBase}/${encodeURIComponent(char)}.json`;

        const res = await fetch(url, { mode: "cors" });
        if (!res.ok) {
          throw new Error(`Stroke data not found for "${char}" (HTTP ${res.status})`);
        }
        const data = await res.json();

        // Expected fields in Hanzi Writer Data:
        // { strokes: [path...], medians: [ [ [x,y], ... ], ... ] }
        if (!data || !Array.isArray(data.strokes) || !Array.isArray(data.medians)) {
          throw new Error(`Unexpected data shape for "${char}"`);
        }

        cache.set(char, data);
        return data;
      }

      return { loadCharData };
    })();

    function createSvgEl(tag) {
      return document.createElementNS("http://www.w3.org/2000/svg", tag);
    }

    function clearEl(el) {
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function firstPoint(median) {
      if (!Array.isArray(median) || median.length === 0) return null;
      const p = median[0];
      if (!Array.isArray(p) || p.length < 2) return null;
      return { x: p[0], y: p[1] };
    }

    function medianToPathD(median) {
      // Convert [[x,y],[x,y],...] to "M x y L x y ..."
      if (!Array.isArray(median) || median.length < 2) return "";
      const parts = [];
      for (let i = 0; i < median.length; i++) {
        const pt = median[i];
        if (!Array.isArray(pt) || pt.length < 2) continue;
        const cmd = (i === 0) ? "M" : "L";
        parts.push(`${cmd} ${pt[0]} ${pt[1]}`);
      }
      return parts.join(" ");
    }

    async function renderStrokeDiagram(container, char, options = {}) {
      const opts = {
        width: options.width ?? 400,
        height: options.height ?? 400,
        padding: options.padding ?? 20,

        showOutline: options.showOutline ?? true,
        showMedians: options.showMedians ?? true,
        showNumbers: options.showNumbers ?? true,
        showArrows: options.showArrows ?? true,

        outlineStrokeWidth: options.outlineStrokeWidth ?? 3,
        medianStrokeWidth: options.medianStrokeWidth ?? 2,

        outlineColor: options.outlineColor ?? "#111",
        medianColor: options.medianColor ?? "#1e5cff",
        numberColor: options.numberColor ?? "#d11",

        // If you want a different CDN version/base:
        cdnBase: options.cdnBase ?? "https://unpkg.com/hanzi-writer-data@2.0.1",

        // Hanzi Writer data uses a 1024x1024-ish coordinate space; viewBox 0..1024 works well
        viewBox: options.viewBox ?? "0 0 1024 1024",
      };

      // Allow passing an element or an element id
      const host = (typeof container === "string") ? document.getElementById(container) : container;
      if (!host) throw new Error("Container not found");

      clearEl(host);
      host.style.width = `${opts.width}px`;
      host.style.height = `${opts.height}px`;

      // Create SVG root
      const svg = createSvgEl("svg");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", opts.viewBox);
      svg.setAttribute("role", "img");
      svg.setAttribute("aria-label", `Stroke order diagram for ${char}`);
      
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      svg.style.display = "block";


      // defs: arrow marker
      const defs = createSvgEl("defs");
      if (opts.showArrows) {
        const marker = createSvgEl("marker");
        marker.setAttribute("id", "arrow");
        marker.setAttribute("markerWidth", "10");
        marker.setAttribute("markerHeight", "10");
        marker.setAttribute("refX", "8");
        marker.setAttribute("refY", "3");
        marker.setAttribute("orient", "auto");
        marker.setAttribute("markerUnits", "strokeWidth");

        const arrowPath = createSvgEl("path");
        arrowPath.setAttribute("d", "M0,0 L9,3 L0,6 Z");
        arrowPath.setAttribute("fill", opts.medianColor);

        marker.appendChild(arrowPath);
        defs.appendChild(marker);
      }
      svg.appendChild(defs);

      // Load data
      let data;
      try {
        data = await HanziStrokeData.loadCharData(char, { cdnBase: opts.cdnBase });
      } catch (err) {
        const msg = createSvgEl("text");
        msg.setAttribute("x", "50%");
        msg.setAttribute("y", "50%");
        msg.setAttribute("text-anchor", "middle");
        msg.setAttribute("dominant-baseline", "middle");
        msg.setAttribute("fill", "#b00");
        msg.setAttribute("font-size", "48");
        msg.textContent = `No data for "${char}"`;
        svg.appendChild(msg);
        host.appendChild(svg);
        throw err;
      }

      const strokesG = createSvgEl("g");
      const mediansG = createSvgEl("g");
      const numbersG = createSvgEl("g");

      // Outline strokes
      if (opts.showOutline) {
        for (const d of data.strokes) {
          const p = createSvgEl("path");
          p.setAttribute("d", d);
          p.setAttribute("fill", "none");
          p.setAttribute("stroke", opts.outlineColor);
          p.setAttribute("stroke-width", String(opts.outlineStrokeWidth));
          p.setAttribute("stroke-linecap", "round");
          p.setAttribute("stroke-linejoin", "round");
          strokesG.appendChild(p);
        }
      }

      // Medians + arrows + numbers
      for (let i = 0; i < data.medians.length; i++) {
        const median = data.medians[i];

        if (opts.showMedians) {
          const md = medianToPathD(median);
          if (md) {
            const mpath = createSvgEl("path");
            mpath.setAttribute("d", md);
            mpath.setAttribute("fill", "none");
            mpath.setAttribute("stroke", opts.medianColor);
            mpath.setAttribute("stroke-width", String(opts.medianStrokeWidth));
            mpath.setAttribute("stroke-linecap", "round");
            mpath.setAttribute("stroke-linejoin", "round");
            mpath.setAttribute("stroke-dasharray", "10 10");

            if (opts.showArrows) {
              mpath.setAttribute("marker-end", "url(#arrow)");
            }

            mediansG.appendChild(mpath);
          }
        }

        if (opts.showNumbers) {
          const p0 = firstPoint(median);
          if (p0) {
            const t = createSvgEl("text");
            t.setAttribute("x", String(p0.x));
            t.setAttribute("y", String(p0.y));
            t.setAttribute("fill", opts.numberColor);
            t.setAttribute("font-size", "44");
            t.setAttribute("font-weight", "700");
            t.setAttribute("paint-order", "stroke");
            t.setAttribute("stroke", "#fff");
            t.setAttribute("stroke-width", "6");
            t.setAttribute("dominant-baseline", "central");

            // Slight offset so the number doesn't sit exactly on the median start
            t.setAttribute("dx", "10");
            t.setAttribute("dy", "-10");

            t.textContent = String(i + 1);
            numbersG.appendChild(t);
          }
        }
      }

      svg.appendChild(strokesG);
      svg.appendChild(mediansG);
      svg.appendChild(numbersG);

      host.appendChild(svg);
      return { svg, data };
    }

    // Demo usage
    (async () => {
      const target = document.getElementById("target");
      try {
        await renderStrokeDiagram(target, "我", {
          width: 420,
          height: 420,
          showOutline: true,
          showMedians: true,
          showNumbers: true,
          showArrows: true,
        });
      } catch (e) {
        // Swallow here; errors are already rendered in SVG + thrown for debugging
        console.warn(e);
      }

      // Quick test: click anywhere to cycle a few characters
      const chars = ["我", "永", "愛", "龍", "學", "心"];
      let idx = 0;
      document.body.addEventListener("click", async () => {
        idx = (idx + 1) % chars.length;
        try {
          await renderStrokeDiagram(target, chars[idx]);
        } catch (e) {
          console.warn(e);
        }
      });
    })();
  </script>
</body>
</html>
