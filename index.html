<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chinese Stroke Order Playground</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 20px; }
    #target { width: 420px; height: 420px; border: 1px solid #ddd; display: grid; place-items: center; }
    .search-container { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; }
    #searchInput { padding: 8px 12px; font-size: 16px; border: 1px solid #ccc; border-radius: 4px; min-width: 300px; }
    #searchButton { padding: 8px 16px; font-size: 16px; background: #1e5cff; color: white; border: none; border-radius: 4px; cursor: pointer; }
    #searchButton:hover { background: #1548cc; }
    .error-message { color: #d11; font-size: 14px; margin-top: 5px; }
    .navigation-container { margin-top: 20px; display: flex; gap: 10px; align-items: center; justify-content: center; max-width: 420px; }
    .nav-button { padding: 8px 16px; font-size: 16px; background: #1e5cff; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .nav-button:hover:not(:disabled) { background: #1548cc; }
    .nav-button:disabled { background: #ccc; cursor: not-allowed; }
    .char-indicator { font-size: 14px; color: #666; min-width: 100px; text-align: center; }
  </style>
</head>
<body>
  <h2>Stroke Order Playground</h2>
  <div class="search-container">
    <input type="text" id="searchInput" placeholder="Enter Chinese characters (e.g., 我愛你)" aria-label="Chinese characters search" />
    <button id="searchButton">Search</button>
  </div>
  <div id="errorMessage" class="error-message"></div>
  <div id="target"></div>
  <div class="navigation-container">
    <button id="prevButton" class="nav-button" aria-label="Previous character">← Previous</button>
    <span id="charIndicator" class="char-indicator" aria-live="polite" aria-atomic="true"></span>
    <button id="nextButton" class="nav-button" aria-label="Next character">Next →</button>
  </div>

  <script>
    // ----------------------------
    // Helpers
    // ----------------------------
    function createSvgEl(tag) {
      return document.createElementNS("http://www.w3.org/2000/svg", tag);
    }

    function clearEl(el) {
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function firstPoint(median) {
      if (!Array.isArray(median) || median.length === 0) return null;
      const p = median[0];
      if (!Array.isArray(p) || p.length < 2) return null;
      return { x: p[0], y: p[1] };
    }

    function medianToPathD(median) {
      if (!Array.isArray(median) || median.length < 2) return "";
      const parts = [];
      for (let i = 0; i < median.length; i++) {
        const pt = median[i];
        if (!Array.isArray(pt) || pt.length < 2) continue;
        const cmd = (i === 0) ? "M" : "L";
        parts.push(`${cmd} ${pt[0]} ${pt[1]}`);
      }
      return parts.join(" ");
    }

    // ----------------------------
    // Data loader (CDN + cache)
    // ----------------------------
    const HanziStrokeData = (() => {
      const cache = new Map();

      function toCodePoints(str) {
        const cps = [];
        for (const ch of str) cps.push(ch.codePointAt(0));
        return cps;
      }

      function isSingleGrapheme(str) {
        const cps = toCodePoints(str);
        return cps.length === 1;
      }

      async function loadCharData(char, opts = {}) {
        if (!isSingleGrapheme(char)) {
          throw new Error(`Expected a single character, got "${char}"`);
        }
        if (cache.has(char)) return cache.get(char);

        const cdnBase = opts.cdnBase || "https://unpkg.com/hanzi-writer-data@2.0.1";
        const url = `${cdnBase}/${encodeURIComponent(char)}.json`;

        const res = await fetch(url, { mode: "cors" });
        if (!res.ok) {
          throw new Error(`Stroke data not found for "${char}" (HTTP ${res.status})`);
        }
        const data = await res.json();

        if (!data || !Array.isArray(data.strokes) || !Array.isArray(data.medians)) {
          throw new Error(`Unexpected data shape for "${char}"`);
        }

        cache.set(char, data);
        return data;
      }

      return { loadCharData };
    })();

    // ----------------------------
    // Main renderer
    // ----------------------------
    async function renderStrokeDiagram(container, char, options = {}) {
      const opts = {
        width: options.width ?? 400,
        height: options.height ?? 400,
        padding: options.padding ?? 20,

        showOutline: options.showOutline ?? true,
        showMedians: options.showMedians ?? true,
        showNumbers: options.showNumbers ?? true,
        showArrows: options.showArrows ?? true,

        outlineStrokeWidth: options.outlineStrokeWidth ?? 3,
        medianStrokeWidth: options.medianStrokeWidth ?? 2,

        outlineColor: options.outlineColor ?? "#111",
        medianColor: options.medianColor ?? "#1e5cff",
        numberColor: options.numberColor ?? "#d11",

        cdnBase: options.cdnBase ?? "https://unpkg.com/hanzi-writer-data@2.0.1",
        viewBox: options.viewBox ?? "0 0 1024 1024",
      };

      const host = (typeof container === "string") ? document.getElementById(container) : container;
      if (!host) throw new Error("Container not found");

      clearEl(host);
      host.style.width = `${opts.width}px`;
      host.style.height = `${opts.height}px`;

      const svg = createSvgEl("svg");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", opts.viewBox);
      svg.setAttribute("role", "img");
      svg.setAttribute("aria-label", `Stroke order diagram for ${char}`);
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      svg.style.display = "block";

      // defs: arrow marker
      const defs = createSvgEl("defs");
      if (opts.showArrows) {
        const marker = createSvgEl("marker");
        marker.setAttribute("id", "arrow");
        marker.setAttribute("markerWidth", "10");
        marker.setAttribute("markerHeight", "10");
        marker.setAttribute("refX", "8");
        marker.setAttribute("refY", "3");
        marker.setAttribute("orient", "auto");
        marker.setAttribute("markerUnits", "strokeWidth");

        const arrowPath = createSvgEl("path");
        arrowPath.setAttribute("d", "M0,0 L9,3 L0,6 Z");
        arrowPath.setAttribute("fill", opts.medianColor);

        marker.appendChild(arrowPath);
        defs.appendChild(marker);
      }
      svg.appendChild(defs);

      // Load data
      let data;
      try {
        data = await HanziStrokeData.loadCharData(char, { cdnBase: opts.cdnBase });
      } catch (err) {
        const msg = createSvgEl("text");
        msg.setAttribute("x", "50%");
        msg.setAttribute("y", "50%");
        msg.setAttribute("text-anchor", "middle");
        msg.setAttribute("dominant-baseline", "middle");
        msg.setAttribute("fill", "#b00");
        msg.setAttribute("font-size", "48");
        msg.textContent = `No data for "${char}"`;
        svg.appendChild(msg);
        host.appendChild(svg);
        throw err;
      }

      // ----------------------------
      // Center character properly in the display box
      // ----------------------------
      const flipG = createSvgEl("g");
      // Scale to 90% to leave some padding, flip Y-axis, and ensure centering
      flipG.setAttribute("transform", "translate(512,512) scale(0.90,-0.90) translate(-512,-512)");

      svg.appendChild(flipG);

      const strokesG = createSvgEl("g");
      const mediansG = createSvgEl("g");
      const numbersG = createSvgEl("g");

      // Outline strokes
      if (opts.showOutline) {
        for (const d of data.strokes) {
          const p = createSvgEl("path");
          p.setAttribute("d", d);
          p.setAttribute("fill", "none");
          p.setAttribute("stroke", opts.outlineColor);
          p.setAttribute("stroke-width", String(opts.outlineStrokeWidth));
          p.setAttribute("stroke-linecap", "round");
          p.setAttribute("stroke-linejoin", "round");
          strokesG.appendChild(p);
        }
      }

      // Medians + arrows + numbers
      for (let i = 0; i < data.medians.length; i++) {
        const median = data.medians[i];

        if (opts.showMedians) {
          const md = medianToPathD(median);
          if (md) {
            const mpath = createSvgEl("path");
            mpath.setAttribute("d", md);
            mpath.setAttribute("fill", "none");
            mpath.setAttribute("stroke", opts.medianColor);
            mpath.setAttribute("stroke-width", String(opts.medianStrokeWidth));
            mpath.setAttribute("stroke-linecap", "round");
            mpath.setAttribute("stroke-linejoin", "round");
            mpath.setAttribute("stroke-dasharray", "10 10");

            if (opts.showArrows) {
              mpath.setAttribute("marker-end", "url(#arrow)");
            }

            mediansG.appendChild(mpath);
          }
        }

        if (opts.showNumbers) {
          const p0 = firstPoint(median);
          if (p0) {
            const t = createSvgEl("text");
            t.setAttribute("x", String(p0.x));
            t.setAttribute("y", String(p0.y));
            t.setAttribute("fill", opts.numberColor);
            t.setAttribute("font-size", "44");
            t.setAttribute("font-weight", "700");
            t.setAttribute("paint-order", "stroke");
            t.setAttribute("stroke", "#fff");
            t.setAttribute("stroke-width", "6");
            t.setAttribute("dominant-baseline", "central");

            // Slight offset so the number doesn't sit exactly on the median start
            t.setAttribute("dx", "10");
            t.setAttribute("dy", "-10");

            // Counter-flip ONLY the text so it stays upright inside flipG
            t.setAttribute(
              "transform",
              `translate(${p0.x},${p0.y}) scale(1,-1) translate(${-p0.x},${-p0.y})`
            );

            t.textContent = String(i + 1);
            numbersG.appendChild(t);
          }
        }
      }

      // Append groups into the flipped coordinate group
      flipG.appendChild(strokesG);
      flipG.appendChild(mediansG);
      flipG.appendChild(numbersG);

      host.appendChild(svg);
      return { svg, data };
    }

    // ----------------------------
    // Demo usage
    // ----------------------------
    (async () => {
      const target = document.getElementById("target");
      const searchInput = document.getElementById("searchInput");
      const searchButton = document.getElementById("searchButton");
      const errorMessage = document.getElementById("errorMessage");
      const prevButton = document.getElementById("prevButton");
      const nextButton = document.getElementById("nextButton");
      const charIndicator = document.getElementById("charIndicator");

      let characters = [];
      let currentIndex = 0;

      function updateNavigation() {
        if (characters.length === 0) {
          prevButton.disabled = true;
          nextButton.disabled = true;
          charIndicator.textContent = "";
          return;
        }
        
        prevButton.disabled = currentIndex === 0;
        nextButton.disabled = currentIndex === characters.length - 1;
        charIndicator.textContent = `${currentIndex + 1} of ${characters.length}`;
      }

      async function displayCharacter(char) {
        try {
          await renderStrokeDiagram(target, char, {
            width: 420,
            height: 420,
            showOutline: true,
            showMedians: true,
            showNumbers: true,
            showArrows: true,
          });
          errorMessage.textContent = "";
        } catch (e) {
          console.warn(e);
          errorMessage.textContent = `Error: No stroke data found for "${char}". Please try a different character.`;
        }
      }

      async function showCurrentCharacter() {
        if (characters.length > 0 && currentIndex >= 0 && currentIndex < characters.length) {
          await displayCharacter(characters[currentIndex]);
          updateNavigation();
        }
      }

      // Initial render with a default character
      characters = ["我"];
      currentIndex = 0;
      await showCurrentCharacter();

      // Search button click handler
      searchButton.addEventListener("click", async () => {
        const input = searchInput.value.trim();
        if (!input) {
          errorMessage.textContent = "Please enter Chinese characters.";
          return;
        }
        
        characters = Array.from(input);
        currentIndex = 0;
        await showCurrentCharacter();
      });

      // Enter key handler
      searchInput.addEventListener("keypress", async (e) => {
        if (e.key === "Enter") {
          searchButton.click();
        }
      });

      // Previous button handler
      prevButton.addEventListener("click", async () => {
        if (currentIndex > 0) {
          currentIndex--;
          await showCurrentCharacter();
        }
      });

      // Next button handler
      nextButton.addEventListener("click", async () => {
        if (currentIndex < characters.length - 1) {
          currentIndex++;
          await showCurrentCharacter();
        }
      });

      // Keyboard arrow key navigation
      document.addEventListener("keydown", (e) => {
        // Don't handle arrow keys if user is typing in the search input
        if (document.activeElement === searchInput) {
          return;
        }
        
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          prevButton.click();
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          nextButton.click();
        }
      });
    })();
  </script>
</body>
</html>
